{"ast":null,"code":"/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = {\n  passive: true,\n  capture: true\n};\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\n\nexport const firstInputPolyfill = onFirstInput => {\n  callbacks.push(onFirstInput);\n  reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n  callbacks = [];\n  firstInputDelay = -1;\n  firstInputEvent = null;\n  eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\n\nconst recordFirstInputDelay = (delay, event) => {\n  if (!firstInputEvent) {\n    firstInputEvent = event;\n    firstInputDelay = delay;\n    firstInputTimeStamp = new Date();\n    eachEventType(removeEventListener);\n    reportFirstInputDelayIfRecordedAndValid();\n  }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\n\n\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n  // In some cases the recorded delay is clearly wrong, e.g. it's negative\n  // or it's larger than the delta between now and initialization.\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n  // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n  if (firstInputDelay >= 0 && // @ts-ignore (subtracting two dates always returns a number)\n  firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n    const entry = {\n      entryType: 'first-input',\n      name: firstInputEvent.type,\n      target: firstInputEvent.target,\n      cancelable: firstInputEvent.cancelable,\n      startTime: firstInputEvent.timeStamp,\n      processingStart: firstInputEvent.timeStamp + firstInputDelay\n    };\n    callbacks.forEach(function (callback) {\n      callback(entry);\n    });\n    callbacks = [];\n  }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\n\n\nconst onPointerDown = (delay, event) => {\n  /**\n   * Responds to 'pointerup' events and records a delay. If a pointer up event\n   * is the next event after a pointerdown event, then it's not a scroll or\n   * a pinch/zoom.\n   */\n  const onPointerUp = () => {\n    recordFirstInputDelay(delay, event);\n    removePointerEventListeners();\n  };\n  /**\n   * Responds to 'pointercancel' events and removes pointer listeners.\n   * If a 'pointercancel' is the next event to fire after a pointerdown event,\n   * it means this is a scroll or pinch/zoom interaction.\n   */\n\n\n  const onPointerCancel = () => {\n    removePointerEventListeners();\n  };\n  /**\n   * Removes added pointer event listeners.\n   */\n\n\n  const removePointerEventListeners = () => {\n    removeEventListener('pointerup', onPointerUp, listenerOpts);\n    removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n  };\n\n  addEventListener('pointerup', onPointerUp, listenerOpts);\n  addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\n\n\nconst onInput = event => {\n  // Only count cancelable events, which should trigger behavior\n  // important to the user.\n  if (event.cancelable) {\n    // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n    // (epoch time) instead of the newer `DOMHighResTimeStamp`\n    // (document-origin time). To check for that we assume any timestamp\n    // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n    // the `Date` object rather than `performance.now()`.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    const isEpochTime = event.timeStamp > 1e12;\n    const now = isEpochTime ? new Date() : performance.now(); // Input delay is the delta between when the system received the event\n    // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n\n    const delay = now - event.timeStamp;\n\n    if (event.type == 'pointerdown') {\n      onPointerDown(delay, event);\n    } else {\n      recordFirstInputDelay(delay, event);\n    }\n  }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\n\n\nconst eachEventType = callback => {\n  const eventTypes = ['mousedown', 'keydown', 'touchstart', 'pointerdown'];\n  eventTypes.forEach(type => callback(type, onInput, listenerOpts));\n};","map":{"version":3,"sources":["/Users/yixuanliao/sarry94118/2021/spring/02/petfinder/login:register/petfinder-project/node_modules/web-vitals/dist/modules/lib/polyfills/firstInputPolyfill.js"],"names":["firstInputEvent","firstInputDelay","firstInputTimeStamp","callbacks","listenerOpts","passive","capture","startTimeStamp","Date","firstInputPolyfill","onFirstInput","push","reportFirstInputDelayIfRecordedAndValid","resetFirstInputPolyfill","eachEventType","addEventListener","recordFirstInputDelay","delay","event","removeEventListener","entry","entryType","name","type","target","cancelable","startTime","timeStamp","processingStart","forEach","callback","onPointerDown","onPointerUp","removePointerEventListeners","onPointerCancel","onInput","isEpochTime","now","performance","eventTypes"],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet firstInputEvent;\nlet firstInputDelay;\nlet firstInputTimeStamp;\nlet callbacks;\nconst listenerOpts = { passive: true, capture: true };\nconst startTimeStamp = new Date();\n/**\n * Accepts a callback to be invoked once the first input delay and event\n * are known.\n */\nexport const firstInputPolyfill = (onFirstInput) => {\n    callbacks.push(onFirstInput);\n    reportFirstInputDelayIfRecordedAndValid();\n};\nexport const resetFirstInputPolyfill = () => {\n    callbacks = [];\n    firstInputDelay = -1;\n    firstInputEvent = null;\n    eachEventType(addEventListener);\n};\n/**\n * Records the first input delay and event, so subsequent events can be\n * ignored. All added event listeners are then removed.\n */\nconst recordFirstInputDelay = (delay, event) => {\n    if (!firstInputEvent) {\n        firstInputEvent = event;\n        firstInputDelay = delay;\n        firstInputTimeStamp = new Date;\n        eachEventType(removeEventListener);\n        reportFirstInputDelayIfRecordedAndValid();\n    }\n};\n/**\n * Reports the first input delay and event (if they're recorded and valid)\n * by running the array of callback functions.\n */\nconst reportFirstInputDelayIfRecordedAndValid = () => {\n    // In some cases the recorded delay is clearly wrong, e.g. it's negative\n    // or it's larger than the delta between now and initialization.\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/6\n    // - https://github.com/GoogleChromeLabs/first-input-delay/issues/7\n    if (firstInputDelay >= 0 &&\n        // @ts-ignore (subtracting two dates always returns a number)\n        firstInputDelay < firstInputTimeStamp - startTimeStamp) {\n        const entry = {\n            entryType: 'first-input',\n            name: firstInputEvent.type,\n            target: firstInputEvent.target,\n            cancelable: firstInputEvent.cancelable,\n            startTime: firstInputEvent.timeStamp,\n            processingStart: firstInputEvent.timeStamp + firstInputDelay,\n        };\n        callbacks.forEach(function (callback) {\n            callback(entry);\n        });\n        callbacks = [];\n    }\n};\n/**\n * Handles pointer down events, which are a special case.\n * Pointer events can trigger main or compositor thread behavior.\n * We differentiate these cases based on whether or not we see a\n * 'pointercancel' event, which are fired when we scroll. If we're scrolling\n * we don't need to report input delay since FID excludes scrolling and\n * pinch/zooming.\n */\nconst onPointerDown = (delay, event) => {\n    /**\n     * Responds to 'pointerup' events and records a delay. If a pointer up event\n     * is the next event after a pointerdown event, then it's not a scroll or\n     * a pinch/zoom.\n     */\n    const onPointerUp = () => {\n        recordFirstInputDelay(delay, event);\n        removePointerEventListeners();\n    };\n    /**\n     * Responds to 'pointercancel' events and removes pointer listeners.\n     * If a 'pointercancel' is the next event to fire after a pointerdown event,\n     * it means this is a scroll or pinch/zoom interaction.\n     */\n    const onPointerCancel = () => {\n        removePointerEventListeners();\n    };\n    /**\n     * Removes added pointer event listeners.\n     */\n    const removePointerEventListeners = () => {\n        removeEventListener('pointerup', onPointerUp, listenerOpts);\n        removeEventListener('pointercancel', onPointerCancel, listenerOpts);\n    };\n    addEventListener('pointerup', onPointerUp, listenerOpts);\n    addEventListener('pointercancel', onPointerCancel, listenerOpts);\n};\n/**\n * Handles all input events and records the time between when the event\n * was received by the operating system and when it's JavaScript listeners\n * were able to run.\n */\nconst onInput = (event) => {\n    // Only count cancelable events, which should trigger behavior\n    // important to the user.\n    if (event.cancelable) {\n        // In some browsers `event.timeStamp` returns a `DOMTimeStamp` value\n        // (epoch time) instead of the newer `DOMHighResTimeStamp`\n        // (document-origin time). To check for that we assume any timestamp\n        // greater than 1 trillion is a `DOMTimeStamp`, and compare it using\n        // the `Date` object rather than `performance.now()`.\n        // - https://github.com/GoogleChromeLabs/first-input-delay/issues/4\n        const isEpochTime = event.timeStamp > 1e12;\n        const now = isEpochTime ? new Date : performance.now();\n        // Input delay is the delta between when the system received the event\n        // (e.g. event.timeStamp) and when it could run the callback (e.g. `now`).\n        const delay = now - event.timeStamp;\n        if (event.type == 'pointerdown') {\n            onPointerDown(delay, event);\n        }\n        else {\n            recordFirstInputDelay(delay, event);\n        }\n    }\n};\n/**\n * Invokes the passed callback const for =  each event type with t =>he\n * `onInput` const and =  `listenerOpts =>`.\n */\nconst eachEventType = (callback) => {\n    const eventTypes = [\n        'mousedown',\n        'keydown',\n        'touchstart',\n        'pointerdown',\n    ];\n    eventTypes.forEach((type) => callback(type, onInput, listenerOpts));\n};\n"]},"metadata":{},"sourceType":"module"}